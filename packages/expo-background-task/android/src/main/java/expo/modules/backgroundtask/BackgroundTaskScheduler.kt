package expo.modules.backgroundtask

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.Operation
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import androidx.work.await
import com.google.common.util.concurrent.ListenableFuture
import expo.modules.kotlin.AppContext
import kotlinx.coroutines.suspendCancellableCoroutine
import java.time.Duration
import java.util.UUID
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class BackgroundTaskScheduler {
  companion object {
    // Unique identifier (generated by us) to identify the worker
    private const val WORKER_IDENTIFIER = "EXPO_BACKGROUND_WORKER"

    // Log tag
    private val TAG: String = BackgroundTaskScheduler::class.java.simpleName

    /**
     Schedules the worker task to run. The worker should run periodically
     at least every 15 minutes
     */
    suspend fun startWorker(context: Context, appScopeKey: String): Boolean {
      // Ensure we have the react context
      Log.i(TAG, "Enqueuing worker with identifier $WORKER_IDENTIFIER")

      val data = Data.Builder()
      data.putString("appScopeKey", appScopeKey)

      // Create the work request
      val builder = PeriodicWorkRequestBuilder<BackgroundTaskWork>(
        repeatIntervalTimeUnit = TimeUnit.MINUTES,
        // TODO: Configurable?
        repeatInterval = 15
      ).setInputData(data.build())
       .setConstraints(
        Constraints.Builder()
          .setRequiresBatteryNotLow(true)
          .setRequiredNetworkType(NetworkType.CONNECTED)
          .build()
      )

      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        // TODO: We should add more time here - like 15 minutes, 60 minutes etc.
        // Maybe even be configurable on the API side.
        builder.setInitialDelay(Duration.ofSeconds(25))
      }

      // Create work request
      val workRequest = builder.build()

      // Get Work manager
      val workManager = WorkManager.getInstance(context)

      // Enqueue the work
      return try {
        val operation = workManager.enqueueUniquePeriodicWork(
          WORKER_IDENTIFIER,
          ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE,
          workRequest).await()

        Log.i(TAG, "Worker enqueued successfully")
        true
      } catch (e: Exception) {
        Log.e(TAG, "Worker failed to start with error " + e.message)
        false
      }
    }

    /**
    Cancels the worker task
     */
    suspend fun stopWorker (context: Context): Boolean {
      Log.i(TAG, "Cancelling worker with identifier $WORKER_IDENTIFIER")

      // Stop our main worker
      val workManager = WorkManager.getInstance(context)
      return try {
          workManager.cancelUniqueWork(WORKER_IDENTIFIER).await()
          workManager.pruneWork().await()
        } catch (e: Exception) {
          Log.i(TAG, "Stopping worker failed with error " + e.message)
          false
        }
    }

    /**
    Returns true if the worker task is pending
     */
    suspend fun isWorkerRunning(context: Context ): Boolean {
      val workInfo = getWorkerInfo(context)
      return workInfo?.state == WorkInfo.State.RUNNING ||
             workInfo?.state == WorkInfo.State.ENQUEUED
    }

    /**
     * Returns the worker info object from the WorkManager if the worker has been
     * registered, otherwise returns null
     */
    private suspend fun getWorkerInfo(context: Context): WorkInfo? {
      // Get work manager
      val workManager = WorkManager.getInstance(context)

      return try {
        val workInfos = workManager.getWorkInfosForUniqueWork(WORKER_IDENTIFIER).await()
        return workInfos.firstOrNull()
      } catch (e: Exception) {
        Log.i(TAG, "Calling getWorkInfosForUniqueWork failed with error " + e.message)
        null
      }
    }

    /**
     * Helper function for calling functions returning an Operation
     */
    suspend fun Operation.await(): Boolean = suspendCancellableCoroutine { continuation ->
      val future = this.result
      val executor = Executors.newCachedThreadPool()

      future.addListener({
        try {
          future.run { get() }
          continuation.resume(true)
        } catch (e: Exception) {
          continuation.resumeWithException(e)
        } finally {
          executor.shutdown()
        }
      }, executor)

      continuation.invokeOnCancellation {
        future.cancel(true)
        executor.shutdown()
      }
    }

    /**
     * Helper function for calling functions returning a ListenableFuture
     */
    suspend fun <T> ListenableFuture<T>.await(): T = suspendCancellableCoroutine { continuation ->
      val executor = Executors.newCachedThreadPool()

      this.addListener({
        try {
          val result = runCatching { this.get() }
          continuation.resume(result.getOrThrow())
        } catch (e: Exception) {
          continuation.resumeWithException(e)
        } finally {
          executor.shutdown()
        }
      }, executor)

      continuation.invokeOnCancellation {
        this.cancel(true)
        executor.shutdown()
      }
    }
  }
}